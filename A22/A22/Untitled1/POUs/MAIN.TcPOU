<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="MAIN" Id="{bb23f57b-bfaa-4807-862f-695fb779bd1d}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM MAIN
VAR_INPUT
	execute : BOOL;
	manualMode : BOOL;
END_VAR
VAR_OUTPUT
	benderLeft : FoldingMachine;
	
	robotLeft, robotRight : Robot;
	
	skidLeft, skidRight : MaterialStorage;
	magazineLeft, magazineRight : MaterialStorage;
	
	wrapper : WrapMachine;
	overhead : STRING;
	
	insertionLeft, insertionRight : ClampInsertion;	
	insertionBottom : TeknicEIP;
	
	innerSuctions, outerSuctions : ARRAY[Surface.TOP_LEFT..Surface.BOTTOM_RIGHT] OF SuctionPad;
END_VAR
VAR
	demoPairCAR : PositionMaterials;
	demoPairCOR : PositionMaterials;
	demoHeight : REAL := 600; //600mm, 60cm

	robotLeftOutputs, robotRightOutputs : ARRAY[1..50] OF INT;
	
	sectionID : SectionEnum := SectionEnum.CARDBOARD_CORNERGUARD;
	
	step : (IDLE, LOAD_CORNERS, LOAD_FLATS, PUSH, RUN_TO_WRAP_POSITION, WRAP_AND_RELEASE, COMPLETE := 1050);
	i : INT;
	
	ready : BOOL;
	
	loadSet : INT;
	loadStepLeft, loadStepRight : INT;
	cornerSetLeft, cornerSetRight : INT;
	
	iWrap : INT;
	wrapPoints : INT;
	wrapRotations : INT;
	
	releaseDelayTimer : TON;
END_VAR
VAR CONSTANT
	releaseDelay : TIME := T#2S;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[demoPairCAR.position := 0;
demoPairCAR.top := 'CAR20M';
demoPairCAR.left := 'CAR20S';
demoPairCAR.right := 'CAR20S';
demoPairCAR.bottom := 'CAR28S';
demoPairCAR.wrapRotations := 4;
demoPairCar.wrapPoints := 4;

demoPairCOR.position := 0;
demoPairCOR.topLeft := 'COR48';
demoPairCOR.topRight := 'COR48';
demoPairCOR.bottomLeft := 'COR48';
demoPairCOR.bottomRight := 'COR48';

IF NOT ready THEN
	ready :=
		insertionLeft.homingSequence() AND
		insertionRight.homingSequence() AND
		insertionBottom.homingSequence();
END_IF

CASE step OF
	IDLE:
		IF execute THEN
			execute := FALSE;
			step := LOAD_CORNERS;
		END_IF
	
	LOAD_CORNERS:
		IF load(pair:= demoPairCor) THEN
			IF manualMode AND_THEN NOT execute THEN
				RETURN;
			END_IF
		
			step := LOAD_FLATS;
		END_IF

	LOAD_FLATS:
		IF loadFlats(pair := demoPairCar) THEN
			IF manualMode AND_THEN NOT execute THEN
				RETURN;
			END_IF
			
			step := PUSH;
		END_IF
		
	PUSH:
		insertionBottom.traverse(direction := FALSE);
		IF NOT insertionLeft.alignTarget(demoHeight/2) OR NOT insertionRight.alignTarget(demoHeight/2) THEN
			RETURN;
		END_IF
		
		insertionLeft.press();
		insertionRight.press();
		
		IF insertionBottom.contact AND insertionLeft.contact AND insertionRight.contact THEN
			step := RUN_TO_WRAP_POSITION;
		END_IF
		
	RUN_TO_WRAP_POSITION:
		wrapPoints := MAX(demoPairCAR.wrapPoints, demopairCOR.wrapPoints);
		wrapRotations := MAX(demoPairCAR.wrapRotations, demoPairCOR.wrapRotations);
		
		IF iWrap >= wrapPoints THEN
			step := COMPLETE;
			RETURN;
		END_IF
		
		step := WRAP_AND_RELEASE;
		
	WRAP_AND_RELEASE:
		releaseDelayTimer(IN:= , PT:= releaseDelay, Q=> , ET=> );
		
		IF wrapper.ready OR (NOT wrapper.busy AND NOT wrapper.error) THEN
			wrapper.wrap(wrapRotations);
			releaseDelayTimer.IN := TRUE;
		END_IF
		
		IF releaseDelayTimer.Q THEN
			FOR i:=Surface.TOP_LEFT TO Surface.BOTTOM_RIGHT BY 1 DO
				innerSuctions[i].enable := FALSE;
				outerSuctions[i].enable := FALSE;
			END_FOR
		
			IF NOT insertionLeft.home THEN
				insertionLeft.alignTarget(0);
				insertionLeft.release();
			END_IF
			
			IF NOT insertionRight.home THEN
				insertionRight.alignTarget(0);
				insertionRight.release();
			END_IF
		END_IF
		
		IF wrapper.done AND insertionLeft.home AND insertionRight.home (*AND insertionBottom.home*) THEN
			releaseDelayTimer.IN := FALSE;
			step := WRAP_AND_RELEASE;
		END_IF
	
	COMPLETE:
		iWrap := wrapPoints := wrapRotations := 0;
		step := IDLE;
		
END_CASE]]></ST>
    </Implementation>
    <Folder Name="Cardboard (Corner)" Id="{75e45005-57b6-45af-977a-1cc75cf19289}" />
    <Folder Name="Cardboard (Flat)" Id="{69bbbb84-f428-46bc-8482-36bd2217074a}" />
    <Folder Name="Corner Guards" Id="{6138b1d4-74c6-4a8f-864e-6193654c592a}" />
    <Method Name="changeRobotsEOAT" Id="{71a414a6-260d-4ed7-9b91-4169239414f1}">
      <Declaration><![CDATA[METHOD changeRobotsEOAT : BOOL
VAR_INPUT
	targetTool : SectionEnum;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[(*
IF robotLeft.tool <> sectionID THEN
	MEMSET(ADR(robotLeftOutputs), 0, SIZEOF(robotLeftOutputs));
	robotLeftOutputs[1] := A21.TOOL_CHANGE_CHIPBOARD;
	robotLeft.setParamsAndWait(robotLeftOutputs);
END_IF

IF robotRight.tool <> sectionID THEN
	MEMSET(ADR(robotRightOutputs), 0, SIZEOF(robotRightOutputs));
	robotRightOutputs[1] := A21.TOOL_CHANGE_CHIPBOARD;
	robotRight.setParamsAndWait(robotRightOutputs);
END_IF

changeRobotsEOAT := robotLeft.tool = sectionID AND robotRight.tool = sectionID;
*)]]></ST>
      </Implementation>
    </Method>
    <Method Name="hardwareCall" Id="{ae27e4e1-f18c-46c6-a88d-05763e2b1498}">
      <Declaration><![CDATA[METHOD hardwareCall : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[benderLeft(enable := TRUE);

robotLeft();
robotRight();

skidLeft();
skidRight();

magazineLeft();
magazineRight();

wrapper();

insertionLeft();
insertionRight();
insertionBottom();]]></ST>
      </Implementation>
    </Method>
    <Method Name="leftRobotSequence" Id="{08bffef9-e349-4b7d-9ae3-92f5a7d8876a}" FolderPath="Cardboard (Corner)\">
      <Declaration><![CDATA[METHOD PROTECTED leftRobotSequence : BOOL
VAR_IN_OUT
	actingRobot : Robot;
	skid : MaterialStorage;
	loadStep : INT;
END_VAR
VAR_INPUT
	surfaceID : Surface;
	materialID : STRING;
	foldPos0 : INT;
	foldPos1 : INT;
END_VAR
VAR_OUTPUT
	fail : BOOL;
END_VAR
VAR
	slot : INT;
	
	task : INT;
	param0, param1, param2 : INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF materialID = '' THEN
	leftRobotSequence := TRUE;
	RETURN;
END_IF

benderLeft.setFoldingPositions(foldPos0, foldPos1);

CASE loadStep OF
	0: //skid to bender
		IF NOT skid.findSlot(materialID, atSlot=> slot) THEN
			fail := TRUE;
			RETURN;
		END_IF
		
		IF
			actingRobot.setCommandAndWait(
				task:= A22.TRANSFER_TO_BENDER, 
				param1:= slot, 
				param2:= foldPos0, 
				param3:= foldPos1)
		THEN
			loadStep := 10;
		END_IF
		
	10: //bend
		//IF benderLeft.done THEN
			loadStep := 20;
		//END_IF
		
		
	20: //bender to overhead or left insertion
		CASE surfaceID OF
			Surface.TOP_RIGHT, Surface.BOTTOM_RIGHT: //transfer to overhead
				IF overhead <> '' THEN
					RETURN;
				END_IF
				task := A22.TRANSFER_TO_OVERHEAD;
				
			Surface.TOP_LEFT: //load to insertion
				task:= A22.LOAD_BENDER_TO_UPPER_CORNER;
					
			Surface.BOTTOM_LEFT: //load to insertion
				task := A22.LOAD_BENDER_TO_LOWER_CORNER;
				
		END_CASE
		
		IF
			actingRobot.setCommandAndWait(
				task:= task, 
				param1:= param0, 
				param2:= param1, 
				param3:= param1)
		THEN
			 loadStep := COMPLETE;
		END_IF
	
	COMPLETE:
		IF surfaceID = Surface.TOP_LEFT OR surfaceID = Surface.BOTTOM_LEFT THEN
			innerSuctions[surfaceID].enable := TRUE;
		END_IF
		
		leftRobotSequence := TRUE;
	
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="load" Id="{a681c93d-e590-4020-9185-d7ae010cf638}">
      <Declaration><![CDATA[METHOD PROTECTED load : BOOL
VAR_INPUT
	pair : REFERENCE TO PositionMaterials;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT (robotLeft.operational AND robotRight.operational) THEN
	RETURN;
END_IF

IF NOT (robotLeft.reserve(sectionID) AND robotRight.reserve(sectionID)) THEN //both robots must be reserved first
	RETURN;
END_IF


IF MatchesMaterialType(pair:= pair, materialType:= 'CAR') THEN //is cardboard
	load := loadCornerCardboards(pair:= pair);

ELSIF MatchesMaterialType(pair:= pair, materialType:= 'COR') THEN //is corner guard
	load := loadCornerGuards(pair:= pair);

END_IF


IF load THEN
	robotLeft.release(sectionID);
	robotRight.release(sectionID);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="loadCornerCardboards" Id="{fc6e26f1-7233-42c4-a94a-66d2e256266a}" FolderPath="Cardboard (Corner)\">
      <Declaration><![CDATA[METHOD PROTECTED loadCornerCardboards : BOOL
VAR_INPUT
	pair : REFERENCE TO PositionMaterials;
END_VAR
VAR
	finished : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF cornerSetLeft = 0 THEN //LEFT SIDE
	cornerSetLeft := Surface.TOP_RIGHT;
END_IF

IF
	leftRobotSequence(
		actingRobot:= robotLeft, 
		skid:= skidLeft, 
		surfaceID:= cornerSetLeft,
		loadStep:= loadStepLeft, 
		materialID:= pair.topRight, 
		foldPos0:= pair.topRightFold, 
		foldPos1:= 0, 
		fail=> )
THEN
	CASE cornerSetLeft OF
		Surface.TOP_RIGHT: 
			cornerSetLeft := Surface.TOP_LEFT;
			loadStepLeft := 0;
			
		Surface.TOP_LEFT: 
			cornerSetLeft := Surface.BOTTOM_RIGHT;
			loadStepLeft := 0;
			
		Surface.BOTTOM_RIGHT: 
			cornerSetLeft := Surface.BOTTOM_LEFT;
			loadStepLeft := 0;
			
		Surface.BOTTOM_LEFT: 
			cornerSetLeft := COMPLETE;
			loadStepLeft := COMPLETE;
			
		COMPLETE:
			//
			
	END_CASE
END_IF


IF cornerSetRight = 0 THEN //RIGHT SIDE
	cornerSetRight := Surface.TOP_RIGHT;
END_IF

IF
	rightRobotSequence(
		actingRobot:= robotRight, 
		skid:= skidRight, 
		loadStep:= loadStepRight, 
		materialID:= pair.topRight, 
		surfaceID:= cornerSetRight,
		foldPos1:= pair.topRightFold, 
		foldPos2:= 0, 
		fail=> )
THEN
	CASE cornerSetRight OF
		Surface.TOP_RIGHT: 
			cornerSetRight := Surface.BOTTOM_RIGHT;
			loadStepRight := 0;
			
		Surface.BOTTOM_RIGHT: 
			cornerSetRight := COMPLETE;			
			loadStepRight := COMPLETE;
			
		COMPLETE:
			//
			
	END_CASE
END_IF


IF cornerSetLeft = COMPLETE AND cornerSetRight = COMPLETE THEN
	loadCornerCardboards := TRUE;
	
	loadStepLeft := loadStepRight := 0;
	cornerSetLeft := cornerSetRight := 0;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="loadCornerGuards" Id="{73216583-3bb4-409e-896a-e96f29db7009}" FolderPath="Corner Guards\">
      <Declaration><![CDATA[METHOD PROTECTED loadCornerGuards : BOOL
VAR_INPUT
	pair : REFERENCE TO PositionMaterials;
END_VAR
VAR_OUTPUT
	fail : BOOL;
END_VAR
VAR
	leftFail : BOOL;
	rightFail : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE loadSet OF
	0: //upper corners
		IF 
			loadGuardSequence(
				actingRobot:= robotLeft, 
				robotOutputs:= robotLeftOutputs, 
				actingStorage:= skidLeft, 
				actingLoadStep:= loadStepLeft, 
				surfaceID:= Surface.TOP_LEFT, 
				material:= pair.topLeft, 
				fail=> leftFail)
			AND
			loadGuardSequence(
				actingRobot:= robotRight, 
				robotOutputs:= robotRightOutputs, 
				actingStorage:= skidRight,
				actingLoadStep:= loadStepRight, 
				surfaceID:= Surface.TOP_RIGHT, 
				material:= pair.topRight, 
				fail=> rightFail)
		THEN
			loadStepLeft := loadStepRight := 0;
			loadSet := 10;
		END_IF
		
	10: //lower corners
		IF 
			loadGuardSequence(
				actingRobot:= robotLeft, 
				robotOutputs:= robotLeftOutputs, 
				actingStorage:= skidLeft, 
				actingLoadStep:= loadStepLeft, 
				surfaceID:= Surface.BOTTOM_LEFT, 
				material:= pair.bottomLeft, 
				fail=> leftFail)
			AND
			loadGuardSequence(
				actingRobot:= robotRight, 
				robotOutputs:= robotRightOutputs, 
				actingStorage:= skidRight,
				actingLoadStep:= loadStepRight, 
				surfaceID:= Surface.BOTTOM_RIGHT, 
				material:= pair.bottomRight, 
				fail=> rightFail)
		THEN
			loadStepLeft := loadStepRight := 0;
			loadSet := COMPLETE;
		END_IF
	
	COMPLETE:
		loadStepLeft := loadStepRight := 0;
		loadSet := 0;
		
		loadCornerGuards := TRUE;
END_CASE

fail := MAX(leftFail, rightFail);]]></ST>
      </Implementation>
    </Method>
    <Method Name="loadFlats" Id="{b9a93d4c-938b-4af6-a5a3-5141d50c48d4}" FolderPath="Cardboard (Flat)\">
      <Declaration><![CDATA[METHOD PROTECTED loadFlats : BOOL
VAR_INPUT
	pair : REFERENCE TO PositionMaterials;
END_VAR
VAR_OUTPUT
	error : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE loadSet OF
	0: //top and bottom
		IF 
			loadFlatSequence(
				actingRobot:= robotLeft, 
				robotOutputs:= robotLeftOutputs, 
				actingStorage:= skidLeft, 
				actingLoadStep:= loadStepLeft, 
				surfaceID:= Surface.TOP, 
				material:= pair.top, 
				fail=> )
			AND
			loadFlatSequence(
				actingRobot:= robotRight, 
				robotOutputs:= robotRightOutputs, 
				actingStorage:= skidRight, 
				actingLoadStep:= loadStepRight, 
				surfaceID:= Surface.BOTTOM, 
				material:= pair.bottom, 
				fail=> )
		THEN
			loadStepLeft := loadStepRight := 0;
			loadSet := 10;
		END_IF
		
	10: //sides
		IF 
			loadFlatSequence(
				actingRobot:= robotLeft, 
				robotOutputs:= robotLeftOutputs, 
				actingStorage:= skidLeft, 
				actingLoadStep:= loadStepLeft, 
				surfaceID:= Surface.LEFT, 
				material:= pair.left, 
				fail=> )
			AND
			loadFlatSequence(
				actingRobot:= robotRight, 
				robotOutputs:= robotRightOutputs, 
				actingStorage:= skidRight, 
				actingLoadStep:= loadStepRight, 
				surfaceID:= Surface.RIGHT, 
				material:= pair.right, 
				fail=> )
		THEN
			loadStepLeft := loadStepRight := 0;
			loadSet := COMPLETE;
		END_IF
	
	COMPLETE:
		loadStepLeft := loadStepRight := 0;
		loadSet := 0;
		
		loadFlats := TRUE;
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="loadFlatSequence" Id="{e9b25173-0158-437d-9616-4153dd5d3500}" FolderPath="Cardboard (Flat)\">
      <Declaration><![CDATA[METHOD loadFlatSequence : BOOL
VAR_IN_OUT
	actingRobot : Robot;
	robotOutputs : ARRAY[1..50] OF INT;
	actingStorage : MaterialStorage;
	actingLoadStep : INT;
END_VAR
VAR_INPUT
	surfaceID : Surface;
	material : STRING;
END_VAR
VAR_OUTPUT
	fail : BOOL;
END_VAR
VAR
	slot : INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF material = '' THEN
	loadFlatSequence := TRUE;
	RETURN;
END_IF

CASE actingLoadStep OF
	0:
		IF NOT actingStorage.findSlot(materialID := material, atSlot => slot) THEN
			fail := TRUE;
			RETURN;
		END_IF
		
		MEMSET(ADR(robotOutputs), 0, SIZEOF(robotOutputs));
		CASE surfaceID OF
			Surface.TOP: 					robotOutputs[1] := A22.LOAD_CARDBOARD_TOP;
			Surface.LEFT, Surface.RIGHT: 	robotOutputs[1] := A22.LOAD_CARDBOARD_SIDE;
			Surface.BOTTOM: 				robotOutputs[1] := A22.LOAD_CARDBOARD_BOTTOM;
		END_CASE
		robotOutputs[2] := slot;
		
		IF actingRobot.setParamsAndWait(robotOutputs) THEN
			actingLoadStep := COMPLETE;
		END_IF
		
	COMPLETE:
		loadFlatSequence := TRUE;
	
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="loadGuardSequence" Id="{6d84fe42-26e5-4a1f-b580-8cefdfabe586}" FolderPath="Corner Guards\">
      <Declaration><![CDATA[METHOD loadGuardSequence : BOOL
VAR_IN_OUT
	actingRobot : Robot;
	robotOutputs : ARRAY[1..50] OF INT;
	actingStorage : MaterialStorage;
	actingLoadStep : INT;
END_VAR
VAR_INPUT
	surfaceID : Surface;
	material : STRING;
END_VAR
VAR_OUTPUT
	fail : BOOL;
END_VAR
VAR
	slot : INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF material = '' THEN
	loadGuardSequence := TRUE;
	RETURN;
END_IF

CASE actingLoadStep OF
	0:
		IF NOT actingStorage.findSlot(materialID := material, atSlot => slot) THEN //load from staging table
			fail := TRUE;
			RETURN;
		END_IF
		
		MEMSET(ADR(robotOutputs), 0, SIZEOF(robotOutputs));
		CASE surfaceID OF
			Surface.TOP_LEFT, Surface.TOP_RIGHT: 		robotOutputs[1] := A22.LOAD_CORNER_GUARD_UPPER;
			Surface.BOTTOM_LEFT, Surface.BOTTOM_RIGHT:	robotOutputs[1] := A22.LOAD_CORNER_GUARD_LOWER;
		END_CASE
		robotOutputs[2] := slot;
		
		IF actingRobot.setParamsAndWait(robotOutputs) THEN
			actingLoadStep := COMPLETE;
		END_IF
		
	COMPLETE:
		outerSuctions[surfaceID].enable := TRUE;
		loadGuardSequence := TRUE;
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="rightRobotSequence" Id="{879cd7f3-c4e8-4979-a4c5-8a1bacb14790}" FolderPath="Cardboard (Corner)\">
      <Declaration><![CDATA[METHOD PROTECTED rightRobotSequence : BOOL
VAR_IN_OUT
	actingRobot : Robot;
	skid : MaterialStorage;
	loadStep : INT;
END_VAR
VAR_INPUT
	surfaceID : Surface;
	materialID : STRING;
	foldPos1 : INT;
	foldPos2 : INT;
END_VAR
VAR_OUTPUT
	fail : BOOL;
END_VAR
VAR
	slot : INT;
	
	task : INT;
	param0, param1, param2 : INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF materialID = '' THEN
	rightRobotSequence := TRUE;
	RETURN;
END_IF

CASE loadStep OF
	0: //overhead to insertion
		IF overhead = '' THEN
			RETURN;
		END_IF
		
		CASE surfaceID OF
			Surface.TOP_RIGHT:
				task := A22.LOAD_OVERHEAD_TO_UPPER_CORNER;
				
			Surface.BOTTOM_RIGHT:
				task := A22.LOAD_OVERHEAD_TO_LOWER_CORNER;
				
		END_CASE
		
		IF
			actingRobot.setCommandAndWait(
				task:= task, 
				param1:= slot, 
				param2:= foldPos1, 
				param3:= foldPos2)
		THEN
			loadStep := COMPLETE;
		END_IF
	
	COMPLETE:
		outerSuctions[surfaceID].enable := TRUE;
		rightRobotSequence := TRUE;
	
END_CASE]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="MAIN">
      <LineId Id="230" Count="4" />
      <LineId Id="412" Count="0" />
      <LineId Id="414" Count="0" />
      <LineId Id="235" Count="3" />
      <LineId Id="227" Count="2" />
      <LineId Id="222" Count="4" />
      <LineId Id="2" Count="0" />
      <LineId Id="240" Count="15" />
      <LineId Id="265" Count="5" />
      <LineId Id="459" Count="0" />
      <LineId Id="272" Count="8" />
      <LineId Id="282" Count="6" />
      <LineId Id="330" Count="0" />
      <LineId Id="384" Count="1" />
      <LineId Id="387" Count="0" />
      <LineId Id="332" Count="1" />
      <LineId Id="366" Count="0" />
      <LineId Id="378" Count="1" />
      <LineId Id="335" Count="0" />
      <LineId Id="344" Count="1" />
      <LineId Id="405" Count="1" />
      <LineId Id="347" Count="1" />
      <LineId Id="407" Count="0" />
      <LineId Id="349" Count="1" />
      <LineId Id="391" Count="0" />
      <LineId Id="505" Count="0" />
      <LineId Id="511" Count="0" />
      <LineId Id="513" Count="0" />
      <LineId Id="512" Count="0" />
      <LineId Id="410" Count="0" />
      <LineId Id="399" Count="2" />
      <LineId Id="393" Count="0" />
      <LineId Id="396" Count="0" />
      <LineId Id="402" Count="2" />
      <LineId Id="397" Count="0" />
      <LineId Id="394" Count="0" />
      <LineId Id="360" Count="1" />
      <LineId Id="408" Count="0" />
      <LineId Id="362" Count="0" />
      <LineId Id="300" Count="0" />
      <LineId Id="325" Count="4" />
      <LineId Id="239" Count="0" />
    </LineIds>
    <LineIds Name="MAIN.changeRobotsEOAT">
      <LineId Id="27" Count="0" />
      <LineId Id="10" Count="1" />
      <LineId Id="14" Count="1" />
      <LineId Id="12" Count="0" />
      <LineId Id="17" Count="4" />
      <LineId Id="9" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="28" Count="0" />
    </LineIds>
    <LineIds Name="MAIN.hardwareCall">
      <LineId Id="34" Count="1" />
      <LineId Id="16" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="7" Count="0" />
    </LineIds>
    <LineIds Name="MAIN.leftRobotSequence">
      <LineId Id="1681" Count="57" />
      <LineId Id="1741" Count="2" />
      <LineId Id="1739" Count="1" />
      <LineId Id="946" Count="0" />
    </LineIds>
    <LineIds Name="MAIN.load">
      <LineId Id="327" Count="1" />
      <LineId Id="451" Count="0" />
      <LineId Id="441" Count="0" />
      <LineId Id="440" Count="0" />
      <LineId Id="442" Count="1" />
      <LineId Id="453" Count="0" />
      <LineId Id="412" Count="0" />
      <LineId Id="415" Count="0" />
      <LineId Id="419" Count="1" />
      <LineId Id="417" Count="0" />
      <LineId Id="421" Count="0" />
      <LineId Id="423" Count="0" />
      <LineId Id="422" Count="0" />
      <LineId Id="452" Count="0" />
      <LineId Id="436" Count="0" />
      <LineId Id="434" Count="0" />
      <LineId Id="437" Count="0" />
      <LineId Id="439" Count="0" />
      <LineId Id="438" Count="0" />
    </LineIds>
    <LineIds Name="MAIN.loadCornerCardboards">
      <LineId Id="189" Count="74" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="MAIN.loadCornerGuards">
      <LineId Id="87" Count="2" />
      <LineId Id="124" Count="3" />
      <LineId Id="129" Count="2" />
      <LineId Id="123" Count="0" />
      <LineId Id="132" Count="0" />
      <LineId Id="134" Count="3" />
      <LineId Id="139" Count="2" />
      <LineId Id="133" Count="0" />
      <LineId Id="92" Count="5" />
      <LineId Id="142" Count="17" />
      <LineId Id="101" Count="11" />
      <LineId Id="39" Count="0" />
    </LineIds>
    <LineIds Name="MAIN.loadFlats">
      <LineId Id="35" Count="2" />
      <LineId Id="65" Count="3" />
      <LineId Id="70" Count="2" />
      <LineId Id="64" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="76" Count="6" />
      <LineId Id="74" Count="0" />
      <LineId Id="40" Count="0" />
      <LineId Id="61" Count="0" />
      <LineId Id="42" Count="4" />
      <LineId Id="86" Count="15" />
      <LineId Id="47" Count="0" />
      <LineId Id="49" Count="9" />
      <LineId Id="7" Count="0" />
    </LineIds>
    <LineIds Name="MAIN.loadFlatSequence">
      <LineId Id="22" Count="12" />
      <LineId Id="48" Count="3" />
      <LineId Id="47" Count="0" />
      <LineId Id="36" Count="6" />
      <LineId Id="44" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="MAIN.loadGuardSequence">
      <LineId Id="6" Count="11" />
      <LineId Id="48" Count="3" />
      <LineId Id="53" Count="0" />
      <LineId Id="46" Count="1" />
      <LineId Id="24" Count="4" />
      <LineId Id="45" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="MAIN.rightRobotSequence">
      <LineId Id="315" Count="33" />
      <LineId Id="5" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>