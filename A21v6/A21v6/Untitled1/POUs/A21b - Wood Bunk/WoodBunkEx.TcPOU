<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="WoodBunkEx" Id="{7c192e4b-e9ee-4c1c-a070-15e2c6191789}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK WoodBunkEx
VAR_IN_OUT //controls
	execute : BOOL;
	stop : BOOL;
	
	manualStep : BOOL;
	manualSuction : BOOL;
END_VAR
VAR_IN_OUT //references to required hardware
	robotLeft, robotRight : RobotA21;
	toolStorageLeft, toolStorageRight : A21ToolStorage;
	
	stagingTableLeft, stagingTableRight : StagingTable;
	magazineLeft, magazineRight : SkidMagazine;
	
	strapper : StrapMachine;
	
	horizontalDriveLeft, horizontalDriveRight : AirPiston;
	verticalDriveLeft, verticalDriveRight : ClearLinkMC;
	pistonBottom : SimplePiston;
	
	suctionTop : ARRAY[*] OF SuctionPad; (*1..3*)
	suctionLeft : ARRAY[*] OF SuctionPad; (*1..4*)
	suctionRight : ARRAY[*] OF SuctionPad; (*1..4*)
	suctionBottom : ARRAY[*] OF SuctionPad; (*1..2*)
END_VAR
VAR_OUTPUT
	//ready : BOOL;
	done : BOOL;
	error : BOOL;
END_VAR
VAR //for testing, to be removed when deployoed
	latchLeft, latchRight : BOOL; //prevents SMC sliders from overshooting
	suctionEnableTop, suctionEnableLeft, suctionEnableRight, suctionEnableBottom : BOOL;
END_VAR
VAR //Allen-Bradley-style AOIs encapsulate functionality and reduce the number of module variables
	templateLeft, templateRight : AOI_StagingTemplate;
	stageLeft, stageRight : AOI_StageWoodBunk; 
	loadLeft, loadRight : AOI_LoadWoodBunk;
	
	topSuctionDelay : TON;
	
	step : (IDLE, STAGING, LOAD_WB, PUSH, STRAP, RELEASE, COMPLETE := 1050);
	iPair : INT;
	
	loadStep : INT;
	stageStep : INT;
	
	stageStepLeft, stageStepRight : INT;
	iSlotLeft, iSlotRight : INT;
END_VAR
VAR //local types
	demoHeight : REAL := 600; //mm
	materialsArr : ARRAY[0..GVL.maxPairs] OF PositionMaterials := [
		( position := 0, top := 'WDS20', left := 'WDS20', right := 'WDS20', bottom := 'WDB20' ),
		( position := 69, top := 'WDS20', left := 'WDS20', right := 'WDS20', bottom := 'WDB20' )
	];
	
	insertionLeft, insertionRight : Insertion;
	loadedMaterials : ARRAY[Surface.TOP..Surface.BOTTOM] OF STRING;
END_VAR
VAR CONSTANT
	sectionID : SectionEnum := SectionEnum.WOOD_BUNK;
END_VAR
VAR
	a,b,c,d : BOOL;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[callLocalModules(); //initialize local modules

blocks(); //call local function blocks

IF robotRight.Done THEN
	robotRight.clearCommand();
END_IF

IF stop THEN
	stopSequence(); //stop everything
	RETURN;
END_IF
(*
IF NOT insertionLeft.screw.HomeSet OR NOT insertionRight.screw.HomeSet THEN
	homingSequence(); //homing all motion devices and robots
	RETURN;
END_IF
*)
a S= suctionTop[1].occupied AND suctionTop[2].occupied AND suctionTop[3].occupied;
b S= suctionLeft[1].occupied AND suctionLeft[2].occupied AND suctionLeft[3].occupied AND suctionLeft[4].occupied;
c S= suctionRight[1].occupied AND suctionRight[2].occupied AND suctionRight[3].occupied AND suctionRight[4].occupied;
d S= suctionBottom[1].occupied AND suctionBottom[2].occupied;

CASE step OF
	IDLE:
		IF execute THEN
			execute := FALSE;
			suctionEnableTop := suctionEnableLeft := suctionEnableRight := suctionEnableBottom := FALSE;
			step := STAGING;
		END_IF
		
		SetSuctions(suctionTop, suctionEnableTop);
		SetSuctions(suctionLeft, suctionEnableLeft);
		SetSuctions(suctionRight, suctionEnableRight);
		SetSuctions(suctionBottom, suctionEnableBottom);
		
	STAGING:
		IF NOT done THEN
			done := stage(); //calls stageEx() for both robots
		END_IF
		
		IF
			(manualStep AND_THEN execute) OR
			(NOT manualStep AND_THEN done)
		THEN
			execute := FALSE;
			done := FALSE;
			step := LOAD_WB;
		END_IF
	
	LOAD_WB:
		IF NOT done THEN
			done := load(pairIndex := iPair, error => error);
		END_IF
		
		IF manualSuction THEN
			SetSuctions(suctionTop, suctionEnableTop);
			SetSuctions(suctionLeft, suctionEnableLeft);
			SetSuctions(suctionRight, suctionEnableRight);
			SetSuctions(suctionBottom, suctionEnableBottom);
		END_IF
		
		IF
			(manualStep AND_THEN execute) OR
			(NOT manualStep AND_THEN done)
		THEN
			done := FALSE;
			suctionEnableTop := suctionEnableLeft := suctionEnableRight := suctionEnableBottom := FALSE;
			execute := FALSE;
			
			step := PUSH;
		END_IF
		
	PUSH:
		IF
			(manualStep AND_THEN execute) OR
			(latchLeft AND latchRight AND pistonBottom.extended)
		THEN
			latchLeft := latchRight := FALSE;
			execute := FALSE;
			step := STRAP;
			RETURN;
		END_IF
		
		IF NOT validateSuctionQuality(checkTop:= TRUE, checkLeft:= TRUE, checkRight:= FALSE, checkBottom:= FALSE) THEN
			error := TRUE;
			RETURN;
		END_IF
		(*
		IF 
			insertionLeft.sliderPos <> demoHeight/2 //OR 
			//insertionRight.sliderPos <> demoHeight/2 //OR 
			//NOT insertionBottom.contact
		THEN
			insertionLeft.slideAbsolute(demoHeight/2);
			//insertionRight.slideAbsolute(demoHeight/2);
			RETURN;
		END_IF
		*)
		
		IF insertionLeft.screw.AtInnerLimit THEN
			latchLeft := TRUE;
		ELSIF NOT latchLeft THEN
			insertionLeft.press();
		END_IF
		
		IF insertionRight.screw.AtInnerLimit THEN
			latchRight := TRUE;
		ELSIF NOT latchRight THEN
			insertionRight.press();
		END_IF
		pistonBottom.extend();
		
	STRAP:
		topSuctionDelay(IN:= , PT:= T#1S, Q=> , ET=> );
		
		strapper.bEnable := TRUE;
		IF strapper.done THEN
			topSuctionDelay.IN := FALSE;
			step := RELEASE;
			RETURN;
		END_IF
		
		IF topSuctionDelay.Q THEN
			SetSuctions(suctionTop, FALSE);
			SetSuctions(suctionLeft, FALSE);
			SetSuctions(suctionRight, FALSE);
			SetSuctions(suctionBottom, FALSE);
		ELSIF strapper.atBundleLevel THEN
			topSuctionDelay.IN := TRUE;
		END_IF
		
		IF strapper.ready THEN
			strapper.strap();
		END_IF
		
		IF execute THEN
			topSuctionDelay.IN := FALSE;
			execute := FALSE;
			step := RELEASE;
		END_IF
		
	RELEASE: //release command		
		//insertionLeft.slideAbsolute(0);
		//insertionRight.slideAbsolute(0);
		
		insertionLeft.release();
		insertionRight.release();
		pistonBottom.retract();
		
		IF 
			(insertionLeft.screw.AtHome AND insertionRight.screw.AtHome AND pistonBottom.retracted) OR
			execute
		THEN
			execute := FALSE;
			step := COMPLETE;
		END_IF
	
	COMPLETE:
		//reset everything
		iPair := (iPair + 1) MOD GVL.maxPairs;
		step := IDLE;
		
		a := b := c := d := FALSE;
END_CASE]]></ST>
    </Implementation>
    <Folder Name="Actions" Id="{4a4594ef-dea4-4aa0-b286-04c344ad8bce}" />
    <Action Name="blocks" Id="{45b29fbc-4480-4c5a-b7d6-8db5a7c57a7f}" FolderPath="Actions\">
      <Implementation>
        <ST><![CDATA[templateLeft(
	execute:= , 
	materialsArr:= materialsArr, 
	table:= stagingTableLeft, 
	includeTop:= , 
	includeLeft:= , 
	includeRight:= , 
	includeBottom:= );

templateRight(
	execute:= , 
	materialsArr:= materialsArr, 
	table:= stagingTableRight, 
	includeTop:= , 
	includeLeft:= , 
	includeRight:= , 
	includeBottom:= );
	
stageLeft(
	sectionID:= sectionID, 
	execute:= ,
	robot:= robotLeft, 
	table:= stagingTableLeft, 
	magazine:= magazineLeft, 
	slot:= iSlotLeft, 
	material:= templateLeft.getSlot(iSlotLeft), 
	done=> , 
	error=> );

stageRight(
	sectionID:= sectionID, 
	execute:= ,
	robot:= robotRight, 
	table:= stagingTableRight, 
	magazine:= magazineRight, 
	slot:= iSlotRight, 
	material:= templateRight.getSlot(iSlotRight),
	done=> , 
	error=> );

loadLeft(
	sectionID:= sectionID, 
	execute:= ,
	robot:= robotLeft, 
	table:= stagingTableLeft, 
	suctions:= suctionTop,
	loadedMaterials:= loadedMaterials,
	//recoveryAoiStage:= stageLeft, 
	//recoveryMagazine:= magazineLeft, 
	surfaceID:= , 
	material:= , 
	loadedMaterials=> , 
	done=> , 
	error=> );
	
loadRight(
	sectionID:= sectionID, 
	execute:= ,
	robot:= robotRight, 
	table:= stagingTableRight, 
	suctions:= suctionTop,
	loadedMaterials:= loadedMaterials,
	//recoveryAoiStage:= stageRight, 
	//recoveryMagazine:= magazineRight, 
	surfaceID:= , 
	material:= , 
	loadedMaterials=> , 
	done=> , 
	error=> );]]></ST>
      </Implementation>
    </Action>
    <Action Name="callLocalModules" Id="{8b2708ac-6691-4038-ae66-c4869c7fa2e2}" FolderPath="Actions\">
      <Implementation>
        <ST><![CDATA[{warning disable C0371}

insertionLeft(
	enable:= TRUE, 
	slider:= verticalDriveLeft, 
	screw:= horizontalDriveLeft, 
	contact=> , 
	softContact=> , 
	busy=> , 
	error=> , 
	home=> , 
	homingComplete=> , 
	sliderPos=> );
	
insertionRight(
	enable:= TRUE, 
	slider:= verticalDriveRight, 
	screw:= horizontalDriveRight,  
	contact=> , 
	softContact=> , 
	busy=> , 
	error=> , 
	home=> , 
	homingComplete=> , 
	sliderPos=> );]]></ST>
      </Implementation>
    </Action>
    <Action Name="homingSequence" Id="{7653a770-9078-4c2c-aad4-1564dbc9f3b2}" FolderPath="Actions\">
      <Implementation>
        <ST><![CDATA[insertionLeft.homingSequence();
insertionRight.homingSequence();
pistonBottom.retract();]]></ST>
      </Implementation>
    </Action>
    <Method Name="load" Id="{41d6aef3-60c1-439a-bdd2-e372cfed0011}">
      <Declaration><![CDATA[METHOD PRIVATE load : BOOL
VAR_INPUT
	pairIndex : INT;
END_VAR
VAR_OUTPUT
	error : BOOL;
END_VAR
VAR
	pair : REFERENCE TO PositionMaterials REF= materialsArr[pairIndex];
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[{warning disable C0371}

IF robotLeft.error OR robotRight.error THEN
	error := TRUE;
	RETURN;
	
ELSIF NOT robotLeft.reserve(sectionID) OR NOT robotRight.reserve(sectionID) THEN //loading requires both robots be reserved together
	RETURN;
	
ELSIF //robots have wrong tool
	(robotLeft.tool <> sectionID AND_THEN NOT robotLeft.changeEOAT(targetTool := sectionID)) OR
	(robotRight.tool <> sectionID AND_THEN NOT robotRight.changeEOAT(targetTool := sectionID))
THEN
	RETURN;
	
END_IF

CASE loadStep OF
	0: //top and bottom
		IF loadLeft.done AND loadRight.done THEN
			loadLeft.reset();
			loadRight.reset();
			
			loadLeft.execute := loadRight.execute := FALSE;
			loadStep := 10;
			RETURN;
		END_IF
		
		loadLeft.suctions := suctionTop;
		loadLeft.surfaceID := Surface.TOP;
		loadLeft.material := pair.top;
		
		loadRight.suctions := suctionBottom;
		loadRight.surfaceID := Surface.BOTTOM;
		loadRight.material := pair.bottom;
		
		loadLeft.execute := loadRight.execute := TRUE;
		
	10: //sides
		IF loadLeft.done AND loadRight.done THEN
			loadLeft.reset();
			loadRight.reset();
			
			loadLeft.execute := loadRight.execute := FALSE;
			loadStep := COMPLETE;
			RETURN;
		END_IF
		
		IF loadLeft.recoveryMode THEN //if loading in recovery mode
			//refill table, resume loading when finished
			loadLeft.execute := stageEx(
				robot:= robotLeft, 
				aoiTemplate:= templateLeft, 
				aoiStaging:= stageLeft, 
				stageStep:= stageStepLeft, 
				iSlot:= iSlotLeft, 
				includeTop:= TRUE, 
				includeLeft:= TRUE, 
				includeRight:= FALSE, 
				includeBottom:= FALSE, 
				error=> );
		END_IF
		
		IF loadRight.recoveryMode THEN //if loading in recovery mode
			//refill table, resume loading when finished
			loadRight.execute := stageEx(
				robot:= robotRight, 
				aoiTemplate:= templateRight, 
				aoiStaging:= stageRight, 
				stageStep:= stageStepRight, 
				iSlot:= iSlotRight, 
				includeTop:= FALSE, 
				includeLeft:= FALSE, 
				includeRight:= TRUE, 
				includeBottom:= TRUE, 
				error=> );
		END_IF
		
		loadLeft.suctions := suctionLeft;
		loadLeft.surfaceID := Surface.LEFT;
		loadLeft.material := pair.left;
		
		loadRight.suctions := suctionRight;
		loadRight.surfaceID := Surface.RIGHT;
		loadRight.material := pair.right;
		
		loadLeft.execute := NOT loadLeft.recoveryMode;
		loadRight.execute := NOT loadRight.recoveryMode;
		
	COMPLETE:				
		robotLeft.release(sectionID);
		robotRight.release(sectionID);
		
		loadLeft.execute := loadRight.execute := FALSE;
		
		loadStep := 0;
		load := TRUE;
END_CASE
	
error := loadLeft.error OR loadRight.error;]]></ST>
      </Implementation>
    </Method>
    <Method Name="stage" Id="{394ea3b0-a477-4afc-b551-89e83b2984a7}">
      <Declaration><![CDATA[METHOD PRIVATE stage : BOOL
VAR_OUTPUT
	error : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[{warning disable C0371}
stage :=
	stageEx(
		robot:= robotLeft, 
		aoiTemplate:= templateLeft, 
		aoiStaging:= stageLeft, 
		stageStep:= stageStepLeft, 
		iSlot:= iSlotLeft, 
		includeTop:= TRUE, 
		includeLeft:= TRUE, 
		includeRight:= FALSE, 
		includeBottom:= FALSE, 
		error=> )
	AND
	stageEx(
		robot:= robotRight, 
		aoiTemplate:= templateRight, 
		aoiStaging:= stageRight, 
		stageStep:= stageStepRight, 
		iSlot:= iSlotRight, 
		includeTop:= FALSE, 
		includeLeft:= FALSE, 
		includeRight:= TRUE, 
		includeBottom:= TRUE, 
		error=> );]]></ST>
      </Implementation>
    </Method>
    <Method Name="stageEx" Id="{5592989f-862c-4d1d-a10b-2f36f2ccb694}">
      <Declaration><![CDATA[METHOD PRIVATE stageEx : BOOL
VAR_IN_OUT
	robot : RobotA21;
	aoiTemplate : AOI_StagingTemplate;
	aoiStaging : AOI_StageWoodBunk;
	stageStep : INT;
	iSlot : INT;
END_VAR
VAR_INPUT
	includeTop, includeLeft, includeRight, includeBottom : BOOL; 
END_VAR
VAR_OUTPUT
	error : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[{warning disable C0371}

IF robot.error THEN
	error := TRUE;
	RETURN;
ELSIF robot.reservation <> sectionID AND_THEN NOT robot.reserve(sectionID) THEN
	RETURN;
ELSIF robot.tool <> sectionID AND_THEN NOT robot.changeEOAT(targetTool := sectionID) THEN
	RETURN;
END_IF

CASE stageStep OF
	0: //generate staging template
		IF aoiTemplate.done THEN
			aoiTemplate.execute := FALSE;
			stageStep := 10;
			RETURN;
		END_IF
		
		aoiTemplate.execute := TRUE;
		
		aoiTemplate.includeTop := includeTop;
		aoiTemplate.includeLeft := includeLeft;
		aoiTemplate.includeRight := includeRight;
		aoiTemplate.includeBottom := includeBottom;
		
	10: //stage tables
		IF iSlot > 10 THEN
			aoiStaging.execute := FALSE;			
			stageStep := COMPLETE;
			RETURN;
		END_IF
		
		iSlot := MAX(1, iSlot); //if 0, sets to 1
		iSlot := MIN(iSlot, 999); //prevents overflow
		
		aoiStaging.execute := NOT aoiStaging.busy;
		
		IF aoiStaging.done THEN
			iSlot := iSlot + 1;
			aoiStaging.execute := FALSE;
		END_IF
	
	COMPLETE:
		aoiTemplate.clearTemplate();
		aoiTemplate.execute := FALSE;
		aoiStaging.execute := FALSE;
		aoiStaging.reset();
		
		robot.release(sectionID);
		
		iSlot := 0;
		
		stageEx := TRUE;
		//stageStep := 0;
END_CASE

error := aoiStaging.error;
]]></ST>
      </Implementation>
    </Method>
    <Action Name="stopSequence" Id="{aa2cff5b-4063-4180-a68f-c8e049a6e342}" FolderPath="Actions\">
      <Implementation>
        <ST><![CDATA[insertionLeft.stop();
insertionRight.stop();
pistonBottom.stop();

robotLeft.clearCommand();
robotRight.clearCommand();

//stop conveyors]]></ST>
      </Implementation>
    </Action>
    <Method Name="validateSuctionQuality" Id="{b1904323-60a7-4bcf-ac74-c2042e21b0b7}">
      <Declaration><![CDATA[METHOD PRIVATE validateSuctionQuality : BOOL
VAR_INPUT
	checkTop : BOOL;
	checkLeft : BOOL;
	checkRight : BOOL;
	checkBottom : BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[validateSuctionQuality := 
	(NOT checkTop OR_ELSE SuctionQuality(suctions:= suctionTop)) AND
	(NOT checkLeft OR_ELSE SuctionQuality(suctions:= suctionLeft)) AND
	(NOT checkRight OR_ELSE SuctionQuality(suctions:= suctionRight)) AND
	(NOT checkBottom OR_ELSE SuctionQuality(suctions:= suctionBottom));

(*
validateSuctionQuality := 
	(
		NOT checkTop OR_ELSE InsertionQuality(
			suctions:= suctionTop, 
			insertionMaterial:= loadedMaterials[Surface.TOP], 
			recipeMaterial:= materialsArr[iPair].top)
	) AND
	(
		NOT checkLeft OR_ELSE InsertionQuality(
			suctions:= suctionLeft, 
			insertionMaterial:= loadedMaterials[Surface.LEFT], 
			recipeMaterial:= materialsArr[iPair].left)
	) AND
	(
		NOT checkRight OR_ELSE InsertionQuality(
			suctions:= suctionRight, 
			insertionMaterial:= loadedMaterials[Surface.RIGHT], 
			recipeMaterial:= materialsArr[iPair].right)
	) AND
	(
		NOT checkBottom OR_ELSE InsertionQuality(
			suctions:= suctionBottom, 
			insertionMaterial:= loadedMaterials[Surface.BOTTOM], 
			recipeMaterial:= materialsArr[iPair].bottom)
	);
*)]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="WoodBunkEx">
      <LineId Id="6835" Count="0" />
      <LineId Id="7231" Count="0" />
      <LineId Id="7230" Count="0" />
      <LineId Id="6836" Count="34" />
      <LineId Id="7313" Count="0" />
      <LineId Id="6872" Count="41" />
      <LineId Id="7229" Count="0" />
      <LineId Id="6914" Count="79" />
      <LineId Id="7149" Count="0" />
      <LineId Id="6994" Count="0" />
      <LineId Id="4805" Count="0" />
    </LineIds>
    <LineIds Name="WoodBunkEx.blocks">
      <LineId Id="56" Count="6" />
      <LineId Id="54" Count="0" />
      <LineId Id="63" Count="0" />
      <LineId Id="65" Count="6" />
      <LineId Id="55" Count="0" />
      <LineId Id="64" Count="0" />
      <LineId Id="34" Count="19" />
      <LineId Id="32" Count="1" />
      <LineId Id="2" Count="27" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="WoodBunkEx.callLocalModules">
      <LineId Id="2" Count="0" />
      <LineId Id="5" Count="22" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="WoodBunkEx.homingSequence">
      <LineId Id="2" Count="1" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="WoodBunkEx.load">
      <LineId Id="1193" Count="0" />
      <LineId Id="1573" Count="13" />
      <LineId Id="1572" Count="0" />
      <LineId Id="1405" Count="0" />
      <LineId Id="1107" Count="0" />
      <LineId Id="1360" Count="0" />
      <LineId Id="1415" Count="3" />
      <LineId Id="1463" Count="0" />
      <LineId Id="1419" Count="0" />
      <LineId Id="1421" Count="0" />
      <LineId Id="1414" Count="0" />
      <LineId Id="1432" Count="0" />
      <LineId Id="1375" Count="0" />
      <LineId Id="1587" Count="0" />
      <LineId Id="1378" Count="0" />
      <LineId Id="1494" Count="0" />
      <LineId Id="1376" Count="0" />
      <LineId Id="1588" Count="0" />
      <LineId Id="1380" Count="0" />
      <LineId Id="1464" Count="0" />
      <LineId Id="1495" Count="0" />
      <LineId Id="1137" Count="1" />
      <LineId Id="1536" Count="6" />
      <LineId Id="1535" Count="0" />
      <LineId Id="1543" Count="0" />
      <LineId Id="1514" Count="0" />
      <LineId Id="1562" Count="0" />
      <LineId Id="1552" Count="9" />
      <LineId Id="1547" Count="0" />
      <LineId Id="1515" Count="0" />
      <LineId Id="1591" Count="0" />
      <LineId Id="1593" Count="12" />
      <LineId Id="1592" Count="0" />
      <LineId Id="1413" Count="0" />
      <LineId Id="1382" Count="0" />
      <LineId Id="1589" Count="0" />
      <LineId Id="1383" Count="2" />
      <LineId Id="1590" Count="0" />
      <LineId Id="1381" Count="0" />
      <LineId Id="1497" Count="1" />
      <LineId Id="1519" Count="0" />
      <LineId Id="1330" Count="0" />
      <LineId Id="1185" Count="0" />
      <LineId Id="1189" Count="1" />
      <LineId Id="1500" Count="1" />
      <LineId Id="1191" Count="0" />
      <LineId Id="1503" Count="0" />
      <LineId Id="1192" Count="0" />
      <LineId Id="1361" Count="0" />
      <LineId Id="1493" Count="0" />
      <LineId Id="1390" Count="0" />
    </LineIds>
    <LineIds Name="WoodBunkEx.stage">
      <LineId Id="1128" Count="0" />
      <LineId Id="1126" Count="1" />
      <LineId Id="1105" Count="20" />
      <LineId Id="1030" Count="0" />
    </LineIds>
    <LineIds Name="WoodBunkEx.stageEx">
      <LineId Id="1127" Count="0" />
      <LineId Id="1189" Count="0" />
      <LineId Id="1187" Count="1" />
      <LineId Id="1182" Count="0" />
      <LineId Id="1181" Count="0" />
      <LineId Id="1183" Count="3" />
      <LineId Id="1128" Count="15" />
      <LineId Id="1207" Count="0" />
      <LineId Id="1145" Count="1" />
      <LineId Id="1150" Count="2" />
      <LineId Id="1239" Count="2" />
      <LineId Id="1237" Count="1" />
      <LineId Id="1223" Count="1" />
      <LineId Id="1227" Count="0" />
      <LineId Id="1233" Count="0" />
      <LineId Id="1235" Count="0" />
      <LineId Id="1164" Count="1" />
      <LineId Id="1191" Count="0" />
      <LineId Id="1193" Count="0" />
      <LineId Id="1190" Count="0" />
      <LineId Id="1166" Count="0" />
      <LineId Id="1168" Count="1" />
      <LineId Id="1171" Count="0" />
      <LineId Id="1173" Count="2" />
      <LineId Id="1192" Count="0" />
      <LineId Id="1176" Count="2" />
      <LineId Id="1030" Count="0" />
    </LineIds>
    <LineIds Name="WoodBunkEx.stopSequence">
      <LineId Id="2" Count="4" />
      <LineId Id="1" Count="0" />
      <LineId Id="8" Count="0" />
      <LineId Id="7" Count="0" />
    </LineIds>
    <LineIds Name="WoodBunkEx.validateSuctionQuality">
      <LineId Id="76" Count="3" />
      <LineId Id="74" Count="1" />
      <LineId Id="72" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="60" Count="0" />
      <LineId Id="42" Count="5" />
      <LineId Id="61" Count="0" />
      <LineId Id="48" Count="4" />
      <LineId Id="62" Count="0" />
      <LineId Id="53" Count="4" />
      <LineId Id="63" Count="0" />
      <LineId Id="58" Count="1" />
      <LineId Id="26" Count="0" />
      <LineId Id="64" Count="0" />
      <LineId Id="73" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>