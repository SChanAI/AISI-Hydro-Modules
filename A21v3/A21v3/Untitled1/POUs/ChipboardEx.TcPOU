<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="ChipboardEx" Id="{4fb9c3b0-6386-4034-a58f-58f8ce2d611a}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK ChipboardEx
VAR_IN_OUT //controls
	execute : BOOL;
	stop : BOOL;
	
	manualStep : BOOL;
	manualSuction : BOOL;
END_VAR
VAR_IN_OUT //references to required hardware
	robotLeft, robotRight : RobotA21;
	toolStorageLeft, toolStorageRight : A21ToolStorage;
	
	skidLeft, skidRight : SkidMagazine;
END_VAR
VAR_OUTPUT
	done : BOOL;
	generalError : BOOL;
	failLeft, failRight : BOOL;
END_VAR
VAR //local types
	materialsArr : ARRAY[0..GVL.maxPairs] OF PositionMaterials;
END_VAR
VAR //for testing, to be removed when replaced with pressure sensors
	latchLeft, latchRight : BOOL;
		
	demoPair : PositionMaterials := (
		position := 0,
		top := 'CIP54',
		bottom := 'CIP18');
	
	demoHeight : REAL := 600; //mm
END_VAR
VAR
	insertionMaterials : ARRAY[Surface.TOP..Surface.BOTTOM] OF STRING;
	
	step : (IDLE, RETRACT_CONVEYOR, LOAD_MATERIAL, EXTEND_CONVEYOR, COMPLETE := 1050);
	
	//these 2 ints should replace the 4 ints after
	commandSet : INT;
	commandStepLeft, commandStepRight : INT;
	
	loadSet : INT;
	loadStepLeft, loadStepRight : INT;
	
	iSlotLeft, iSlotRight : INT(1..10);
END_VAR
VAR CONSTANT
	sectionID : SectionEnum := SectionEnum.CHIPBOARD;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[{warning disable C0371}
callLocalModules();

materialsArr[0] := demoPair;

IF stop THEN //may need to turn off suction	
	robotLeft.clearCommand();
	robotRight.clearCommand();
	RETURN;
END_IF

IF FALSE (*conveyors not extended*) THEN
	RETURN;
END_IF

CASE step OF
	IDLE:
		IF execute THEN
			execute := FALSE;
			step := RETRACT_CONVEYOR;
		END_IF
		
	RETRACT_CONVEYOR:
		IF demoPair.bottom <> '' (*retract conveyors*) THEN
			IF TRUE (*BLSC 1-3 retracted*) THEN
				done := TRUE;
			END_IF
		ELSE
			done := TRUE;
		END_IF
		
		IF
			(manualStep AND_THEN execute) OR
			(NOT manualStep AND_THEN done)
		THEN
			done := FALSE;
			step := LOAD_MATERIAL;
		END_IF
		
	LOAD_MATERIAL:
		IF NOT done THEN
			done := load(pair:= demoPair, error => generalError);
		END_IF
		
		IF
			(manualStep AND_THEN execute) OR
			(NOT manualStep AND_THEN done)
		THEN
			done := FALSE;
			execute := FALSE;
			
			step := EXTEND_CONVEYOR;
		END_IF
		
	EXTEND_CONVEYOR:
		IF FALSE (*conveyors not extended*) THEN
			//extend conveyors
		END_IF
		
		IF
			(manualStep AND_THEN execute) OR
			(FALSE) //conveyors extended
		THEN
			done := FALSE;
			step := COMPLETE;
		END_IF
		
	COMPLETE:
		//reset everything
		step := IDLE;
		
END_CASE]]></ST>
    </Implementation>
    <Method Name="callLocalModules" Id="{bea4cf3f-a5a1-4b36-af59-25abcfb940a0}">
      <Declaration><![CDATA[METHOD callLocalModules : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="load" Id="{fb843105-64e1-44e7-8bcd-619ab2de166a}">
      <Declaration><![CDATA[METHOD load : BOOL
VAR_INPUT
	pair : REFERENCE TO PositionMaterials;
END_VAR
VAR_OUTPUT
	error : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[{warning disable C0371}
IF robotLeft.offline AND robotLeft.offline THEN //robots not operational
	error := TRUE;
	RETURN;
END_IF

IF NOT (robotLeft.reserve(sectionID) AND robotRight.reserve(sectionID)) THEN //robots not reserved
	RETURN;
	
ELSIF //wrong tool and not finished changing tool
	(robotLeft.tool <> sectionID AND_THEN NOT robotLeft.changeEOAT(targetTool := sectionID)) OR
	(robotRight.tool <> sectionID AND_THEN NOT robotRight.changeEOAT(targetTool := sectionID))
THEN
	RETURN;
END_IF
//robots ok

CASE loadSet OF
	0: //demo only - only top chipboard loaded by left robot
		IF 
			loadingSequence(
				robot:= robotLeft, 
				storage:= skidLeft, 
				loadStep:= loadStepLeft, 
				surfaceID:= Surface.TOP,
				material:= pair.top, 
				fail=> failLeft)
		THEN
			loadStepLeft := loadStepRight := 0;
			loadSet := 10;
		END_IF
		
	10: //recovery
		IF robotLeft.operational AND NOT robotRight.operational THEN //left ok, right fail
			IF //load bottom using left robot
				loadingSequence(
					robot:= robotLeft, 
					storage:= skidLeft, 
					loadStep:= loadStepLeft, 
					surfaceID:= Surface.BOTTOM,
					material:= pair.top, 
					fail=> failRight) //load bottom with left robot
			THEN
				loadSet := COMPLETE;
			END_IF
			
		ELSIF NOT robotLeft.operational AND robotRight.operational THEN //left fail, right ok
			IF //load top using right robot
				loadingSequence(
					robot:= robotRight, 
					storage:= skidRight, 
					loadStep:= loadStepRight, 
					surfaceID:= Surface.TOP,
					material:= pair.bottom, 
					fail=> ) //load top with right robot
			THEN
				loadSet := COMPLETE;
			END_IF
			
		END_IF
		
	COMPLETE:
		loadSet := 0;
		loadStepLeft := loadStepRight := 0;
		
		robotLeft.release(sectionID);
		robotRight.release(sectionID);
		
		load := TRUE;
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="loadingSequence" Id="{96d77f50-a148-46c4-8ea5-43c584f562c9}">
      <Declaration><![CDATA[METHOD loadingSequence : BOOL
VAR_IN_OUT
	robot : RobotA21;
	storage : MaterialHolder;
	loadStep : INT;
END_VAR
VAR_INPUT
	surfaceID : Surface;
	material : STRING;
END_VAR
VAR_OUTPUT
	fail : BOOL;
END_VAR
VAR
	slot : INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF material = '' THEN
	loadingSequence := TRUE;
	RETURN;
END_IF

CASE loadStep OF
	0:
		robot.clearCommand();
		IF robot.Ready THEN
			step := 10;
		END_IF
		
	10: //grab from chipboard skid
		IF NOT storage.findSlot(materialID := material, atSlot => slot) THEN
			fail := TRUE;
			RETURN;
		ELSIF surfaceID = Surface.BOTTOM (*AND_THEN (*conveyor not lowered*)*) THEN
			//lower conveyor
			RETURN;
		END_IF
		
		IF robot.Done THEN
			step := COMPLETE;
			RETURN;
		END_IF
		
		robot.setGroup(group := 1, value := A21.PLACE_CHIPBOARD_TOP);
		robot.setGroup(group := 2, value := slot);
	(*	
	20: //in between pause
		robot.clearCommand();
		IF robot.Ready THEN
			step := 30;
		END_IF
		
	30: //move to bundle
		MEMSET(ADR(command), 0, SIZEOF(command));
		CASE surfaceID OF
			Surface.TOP: 					robot.setGroup(group := 1, value := A21.PLACE_CHIPBOARD_TO_TOP);
			Surface.BOTTOM: 				robot.setGroup(group := 1, value := A21.PLACE_CHIPBOARD_TO_BOTTOM);
		END_CASE		
		//robot.setGroup(group := 2, value := slot);
		
		IF robot.setCommand(command) THEN
			loadStep := 10;
		END_IF
	*)
	COMPLETE:
		robot.release(sectionID);
		loadingSequence := TRUE;
		
END_CASE]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="ChipboardEx">
      <LineId Id="4957" Count="0" />
      <LineId Id="4887" Count="69" />
      <LineId Id="4806" Count="0" />
    </LineIds>
    <LineIds Name="ChipboardEx.callLocalModules">
      <LineId Id="17" Count="0" />
    </LineIds>
    <LineIds Name="ChipboardEx.load">
      <LineId Id="415" Count="68" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="ChipboardEx.loadingSequence">
      <LineId Id="25" Count="4" />
      <LineId Id="58" Count="0" />
      <LineId Id="137" Count="0" />
      <LineId Id="141" Count="0" />
      <LineId Id="138" Count="2" />
      <LineId Id="158" Count="0" />
      <LineId Id="59" Count="3" />
      <LineId Id="116" Count="1" />
      <LineId Id="162" Count="0" />
      <LineId Id="118" Count="0" />
      <LineId Id="170" Count="0" />
      <LineId Id="163" Count="1" />
      <LineId Id="166" Count="0" />
      <LineId Id="165" Count="0" />
      <LineId Id="167" Count="0" />
      <LineId Id="159" Count="1" />
      <LineId Id="82" Count="1" />
      <LineId Id="155" Count="2" />
      <LineId Id="142" Count="2" />
      <LineId Id="146" Count="4" />
      <LineId Id="169" Count="0" />
      <LineId Id="152" Count="2" />
      <LineId Id="145" Count="0" />
      <LineId Id="94" Count="4" />
      <LineId Id="5" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>